// Generated by CoffeeScript 2.3.1
(function () {
  /*
   * Helpers
   */
  /*
   * Inline Lexer & Compiler
   */
  /*
   * Pedantic grammar
   * not support
   */
  /*
   * Block-Level Grammer
   */
  /*
   * Inline-Level Grammar
   */
  var InlineLexer, Lexer, Parser, Renderer, TextRenderer, baseUrls, block, edit, escape, inline, marked, noop, originIndependentUrl, resolveUrl, rtrim, splitCells, unescape;

  escape = function (html, encode) {
    var amp;
    amp = encode ? /&/g : /&(?!#?\w+;)/g;
    return html.replace(amp, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
  };

  unescape = function (html) {
    // explicitly match decimal, hex, and named HTML entities
    return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function (_, n) {
      n = n.toLowerCase();
      if (n === 'colon') {
        return ':';
      }
      if (n.charAt(0) === '#') {
        if (n.charAt(1) === 'x') {
          return String.fromCharCode(parseInt(n.slice(2), 16));
        } else {
          return String.fromCharCode(parseInt(n.slice(1)));
        }
      } else {
        return '';
      }
    });
  };

  edit = function (regex, opt) {
    var self;
    regex = regex.source || regex;
    opt = opt || '';
    return self = function (name, val) {
      if (name) {
        val = val.source || val;
        val = val.replace(/(^|[^\[])\^/g, '$1');
        regex = regex.replace(name, val);
        return self;
      } else {
        return new RegExp(regex, opt);
      }
    };
  };

  resolveUrl = function (base, href) {
    var key;
    key = ' ' + base;
    if (!baseUrls[key]) {
      // we can ignore everything in base after the last slash of its path component,
      // but we might need to add _that_
      // https://tools.ietf.org/html/rfc3986#section-3
      if (/^[^:]+:\/*[^\/]*$/.test(base)) {
        baseUrls[key] = base + '/';
      } else {
        baseUrls[key] = rtrim(base, '/', true);
      }
    }
    base = baseUrls[key];
    switch (false) {
      case href.slice(0, 2) !== '//':
        return base.replace(/:[\s\S]*/, ':') + href;
      case href.charAt(0) !== '/':
        return base.replace(/(:\/*[^\/]*)[\s\S]*/, '$1') + href;
      default:
        return base + href;
    }
  };

  baseUrls = {};

  originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

  noop = function () {};

  noop.exec = noop;

  splitCells = function (tableRow, count) {
    var cells, i, k, len, o;
    cells = tableRow.replace(/([^\\])\|/g, '$1 |').split(/ +\| */);
    i = 0;
    if (cells.length > count) {
      cells.splice(count);
    } else {
      while (cells.length < count) {
        cells.push('');
      }
    }
    for (i = k = 0, len = cells.length; k < len; i = ++k) {
      o = cells[i];
      cells[i] = o.replace(/\\\|/g, '|');
    }
    return cells;
  };

  // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
  // /c*$/ is vulnerable to REDOS.
  // invert: Remove suffix of non-c chars instead. Default falsey.
  rtrim = function (str, c, invert) {
    var at;
    at = str.length;
    if (0 === at) {
      return '';
    }
    if (invert) {
      while (0 <= at) {
        if (str.slice(at, +at + 1 || 9e9) !== c) {
          at--;
        } else {
          break;
        }
      }
    } else {
      while (0 <= at) {
        if (str.slice(at, +at + 1 || 9e9) === c) {
          at--;
        } else {
          break;
        }
      }
    }
    return str.slice(0, at);
  };

  block = {
    newline: /^ *\n+/,
    code: /^( {4}[^\n]+\n*)+/,
    fences: noop,
    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n|$)/,
    heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n|$)/,
    table: noop,
    blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
    list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
    html: /^ {0,3}(?:<(script|pre|style)[\s>][\s\S]*?(?:<\/\1>[^\n]*\n+|$)|comment[^\n]*(\n+|$)|<\?[\s\S]*?\?>\n*|<![A-Z][\s\S]*?>\n*|<!\[CDATA\[[\s\S]*?\]\]>\n*|<\/?(tag)(?: +|\n|\/?>)[\s\S]*?(?:\n{2,}|$)|<(?!script|pre|style)([a-z][\w-]*)(?:attribute)*? *\/?>(?=\h*\n)[\s\S]*?(?:\n{2,}|$)|<\/(?!script|pre|style)[a-z][\w-]*\s*>(?=\h*\n)[\s\S]*?(?:\n{2,}|$))/,
    def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n|$)/,
    lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n|$)/,
    checkbox: /^\[([ xX])\] +/,
    paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading| {0,3}>|<\/?(?:tag)(?: +|\n|\/?>)|<(?:script|pre|style|!--))[^\n]+)*)/,
    text: /^[^\n]+/
  };

  block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;

  block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;

  block.def = edit(block.def)('label', block._label)('title', block._title)();

  block.with_bullet = /^ *([*+-]|\d+\.) +/;

  block.bullet = /(?:[*+-]|\d+\.)/;

  block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;

  block.item = edit(block.item, 'gm')(/bull/g, block.bullet)();

  block.list = edit(block.list)(/bull/g, block.bullet)('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n|$))')('def', '\\n+(?=' + block.def.source + ')')();

  block._tag = /address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul/;

  block._comment = /<!--(?!-?>)[\s\S]*?-->/;

  block.html = edit(block.html, 'i')('comment', block._comment)('tag', block._tag)('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)();

  block.paragraph = edit(block.paragraph)('hr', block.hr)('heading', block.heading)('lheading', block.lheading)('tag', block._tag)();

  block.blockquote = edit(block.blockquote)('paragraph', block.paragraph)();

  /*
   * Normal Block Grammar
   */
  block.normal = Object.assign({}, block);

  /*
   * GFM Block Grammar
   */
  block.gfm = Object.assign({}, block.normal, {
    fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\n? *\1 *(?:\n|$)/,
    paragraph: /^/,
    heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n|$)/
  });

  block.gfm.paragraph = edit(block.paragraph)('(?!', `(?!${block.gfm.fences.source.replace('\\1', '\\2')}|${block.list.source.replace('\\1', '\\3')}|`)();

  /*
   * GFM + Tables Block Grammar
   */
  block.tables = Object.assign({}, block.gfm, {
    table: /^ *(.*\|.*) *\n *((\|?) *:?-+:? *(?:\| *:?-+:? *)*(\|?))(?:\n *((?:\3.*[^>\n ].*\4(?:\n|$))*)|$)/
  });

  Lexer = function () {
    class Lexer {
      static lex(src, options) {
        return new Lexer(options).lex(src);
      }

      constructor(options1) {
        this.options = options1;
        this.tokens = [];
        this.tokens.notes = [];
        this.tokens.links = {};
        this.rules = block.normal;
        if (this.options.gfm) {
          this.rules = this.options.tables ? block.tables : block.gfm;
        }
      }

      lex(src) {
        src = src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ').replace(/\u00a0/g, ' ').replace(/\u2424/g, '\n');
        return this.token(src, true);
      }

      token(src, top) {
        var align, b, base1, bull, cap, cells, checkbox, checked, header, i, is_ordered, item, k, l, len, len1, loose, m, next, o, ref, ref1, ref2, ref3, space, tag, trim, type;
        while (src) {
          // newline
          if (cap = this.rules.newline.exec(src)) {
            src = src.slice(cap[0].length);
            if (cap[0].length) {
              this.tokens.push({
                type: 'space',
                text: cap[0]
              });
            }
          }
          // code
          if (this.options.indentCode && (cap = this.rules.code.exec(src))) {
            // console.log 'block code', cap
            src = src.slice(cap[0].length);
            cap = cap[0].replace(/^ {4}/gm, '');
            this.tokens.push({
              type: 'code',
              text: cap
            });
            continue;
          }
          // fences (gfm)
          if (cap = this.rules.fences.exec(src)) {
            // console.log 'block fences', cap
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: 'code',
              lang: cap[2],
              text: cap[3] || ''
            });
            continue;
          }
          // heading
          if (cap = this.rules.heading.exec(src)) {
            // console.log 'block heading', cap
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: 'heading',
              depth: cap[1].length,
              text: cap[2]
            });
            continue;
          }
          // table no leading pipe (gfm)
          if (top && (cap = this.rules.table.exec(src))) {
            src = src.slice(cap[0].length);
            trim = /^\|? *|\ *\|? *$/g;
            header = splitCells(cap[1].replace(trim, ''));
            align = cap[2].replace(trim, '').split(/ *\| */);
            cells = (ref = (ref1 = cap[5]) != null ? ref1.replace(/\n$/, '').split('\n').map(o => {
              return o.replace(trim, '');
            }) : void 0) != null ? ref : [];
            item = {
              type: 'table',
              header,
              align,
              cells
            };
            for (i = k = 0, len = align.length; k < len; i = ++k) {
              o = align[i];
              align[i] = /^ *-+: *$/.test(o) ? 'right' : /^ *:-+: *$/.test(o) ? 'center' : /^ *:-+ *$/.test(o) ? 'left' : null;
            }
            ref2 = item.cells;
            for (i = m = 0, len1 = ref2.length; m < len1; i = ++m) {
              o = ref2[i];
              cells[i] = splitCells(o, item.align.length);
            }
            this.tokens.push(item);
            continue;
          }
          // hr
          if (cap = this.rules.hr.exec(src)) {
            // console.log 'block hr', cap
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: 'hr'
            });
            continue;
          }
          // blockquote
          if (cap = this.rules.blockquote.exec(src)) {
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: 'blockquote_start'
            });
            cap = cap[0].replace(/^ *> ?/gm, '');
            // Pass `top` to keep the current
            // "toplevel" state. This is exactly
            // how markdown.pl works.
            this.token(cap, top, true);
            this.tokens.push({
              type: 'blockquote_end'
            });
            continue;
          }
          // list
          if (cap = this.rules.list.exec(src)) {
            // console.log 'block list', cap
            src = src.slice(cap[0].length);
            bull = cap[2];
            is_ordered = "." === bull.slice(-1);
            this.tokens.push({
              type: 'list_start',
              ordered: is_ordered,
              start: is_ordered ? +bull : ''
            });
            // Get each top-level item.
            cap = cap[0].match(this.rules.item);
            next = false;
            l = cap.length;
            i = 0;
            while (i < l) {
              item = cap[i];
              // Remove the list item's bullet
              // so it is seen as the next token.
              space = item.length;
              item = item.replace(this.rules.with_bullet, '');
              if (~item.indexOf('\n ')) {
                space -= item.length;
                item = item.replace(RegExp(`^ {1,${space}}`, "gm"), '');
              }
              // Determine whether the next list item belongs here.
              // Backpedal if it does not belong in this list.
              if (this.options.smartLists && i !== l - 1) {
                b = block.bullet.exec(cap[i + 1])[0];
                if (bull !== b && !(bull.length > 1 && b.length > 1)) {
                  src = cap.slice(i + 1).join('\n') + src;
                  i = l - 1;
                }
              }
              // Determine whether item is loose or not.
              // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
              // for discount behavior.
              loose = next || /\n\n(?!\s*$)/.test(item);
              if (i !== l - 1) {
                next = item.charAt(item.length - 1) === '\n';
                if (!loose) {
                  loose = next;
                }
              }
              // Check for task list items
              checkbox = this.rules.checkbox.exec(item);
              checked = checkbox ? (item = item.replace(this.rules.checkbox, ''), checkbox[1] !== ' ') : void 0;
              type = loose ? 'loose_item_start' : 'list_item_start';
              this.tokens.push({
                checked,
                type,
                task: checked != null
              });
              // Recurse.
              this.token(item, false);
              this.tokens.push({
                type: 'list_item_end'
              });
              i++;
            }
            this.tokens.push({
              type: 'list_end'
            });
            continue;
          }
          // html
          if (cap = this.rules.html.exec(src)) {
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: this.options.sanitize ? 'paragraph' : 'html',
              pre: !this.options.sanitizer && ((ref3 = cap[1]) === 'pre' || ref3 === 'script' || ref3 === 'style'),
              text: cap[0]
            });
            continue;
          }
          // def
          if (top && (cap = this.rules.def.exec(src))) {
            // console.log 'def', cap
            src = src.slice(cap[0].length);
            if (cap[3]) {
              cap[3] = cap[3].slice(1, -1);
            }
            tag = cap[1].toLowerCase();
            (base1 = this.tokens.links)[tag] || (base1[tag] = {
              href: cap[2],
              title: cap[3]
            });
            continue;
          }
          // lheading
          if (cap = this.rules.lheading.exec(src)) {
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: 'heading',
              depth: cap[2] === '=' ? 1 : 2,
              text: cap[1]
            });
            continue;
          }

          // top-level paragraph
          if (top && (cap = this.rules.paragraph.exec(src))) {
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: 'paragraph',
              text: cap[0]
            });
            continue;
          }
          // text
          if (cap = this.rules.text.exec(src)) {
            // Top-level should never reach here.
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: 'text',
              text: cap[0],
              top: top
            });
            continue;
          }
          if (src) {
            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
          }
        }
        return this.tokens;
      }

    };

    Lexer.rules = block;

    return Lexer;
  }.call(this);

  inline = {
    escape: /^\\([!"#$%&'()*+,\-.\/:;<=>?@\[\]\\^_`{|}~])/,
    autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
    url: noop,
    tag: /^comment|^<\/[a-zA-Z][\w:-]*\s*>|^<[a-zA-Z][\w-]*(?:attribute)*?\s*\/?>|^<\?[\s\S]*?\?>|^<![a-zA-Z]+\s[\s\S]*?>|^<!\[CDATA\[[\s\S]*?\]\]>/,
    link: /^!?\[(label)\]\(href(?:\s+(title))?\s*\)/,
    reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
    nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
    strong: /^([_~*=])\1([^\s][\s\S]*?[^\s]|[^\s])\1\1(?!\1)/,
    em: /^_([^\s][\s\S]*?[^\s_])_(?!_)|^_([^\s_][\s\S]*?[^\s])_(?!_)|^\*([^\s][\s\S]*?[^\s*])\*(?!\*)|^\*([^\s*][\s\S]*?[^\s])\*(?!\*)|^_([^\s_])_(?!_)|^\*([^\s*])\*(?!\*)/,
    code: /^(`+)\s*([\s\S]*?[^`]?)\s*\1(?!`)/,
    br: /^ {2,}\n(?!\s*$)/,
    text: /^[\s\S]+?(?=[\\<!\[`*~=\-\^]|\b_| {2,}\n|$)/,
    // extended
    anker: /^\w+-\w+-\w+-\w+-\w+|-\w+-\w+-\w+|-\w+-\w+|-\w+/,
    note: /^\^\[(label)\]/,
    sup: /^\^((?:[^\s^]|\^\^)+?)\^(?!\^)/,
    sub: /^~((?:[^\s~]|~~)+?)~(?!~)/,
    _url_peice: /^$|^mailto:|:\/\/|^(\.{0,2})[\?\#\/]|^[\w()%+:\/]+$/ig
  };

  inline._escapes = edit(inline.escape, 'g')('^', '')();

  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;

  inline._email = /[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;

  inline.autolink = edit(inline.autolink)('scheme', inline._scheme)('email', inline._email)();

  inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;

  inline.tag = edit(inline.tag)('comment', block._comment)('attribute', inline._attribute)();

  inline._label = /(?:\[[^\[\]]*\]|\\[\[\]]?|`[^`]*`|[^\[\]\\])*?/;

  inline._href = /\s*(<(?:\\[<>]?|[^\s<>\\])*>|(?:\\[()]?|\([^\s\x00-\x1f()\\]*\)|[^\s\x00-\x1f()\\])*?)/;

  inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;

  inline.link = edit(inline.link)('label', inline._label)('href', inline._href)('title', inline._title)();

  inline.reflink = edit(inline.reflink)('label', inline._label)();

  inline.note = edit(inline.note)('label', inline._label)();

  /*
   * Normal Inline Grammar
   */
  inline.normal = Object.assign({}, inline);

  /*
   * Pedantic Inline Grammar
   * -- bye --
   */
  /*
   * GFM Inline Grammar
   */
  inline.gfm = Object.assign({}, inline.normal, {
    escape: edit(inline.escape)('])', '~|])')(),
    text: edit(inline.text)(']|', '~]|')('|', '|https?://|ftp://|www\\.|[a-zA-Z0-9.!#$%&\'*+/=?^_`{\\|}~-]+@|')(),
    url: edit(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/)('email', inline._email)(),
    _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/
  });

  /*
   * GFM + Line Breaks Inline Grammar
   */
  inline.breaks = Object.assign({}, inline.gfm, {
    br: edit(inline.br)('{2,}', '*')(),
    text: edit(inline.gfm.text)('{2,}', '*')()
  });

  InlineLexer = function () {
    class InlineLexer {
      static output(src, options) {
        return new InlineLexer(options, options).output(src);
      }

      static escapes(text) {
        return (text != null ? text.replace(InlineLexer.rules._escapes, '$1') : void 0) || text;
      }

      constructor({
        notes: notes1,
        links
      }, options) {
        this.notes = notes1;
        this.links = links;
        this.options = options || marked.defaults;
        this.rules = inline.normal;
        this.renderer = this.options.renderer || new Renderer();
        this.renderer.options = this.options;
        if (!this.notes) {
          throw new Error('Tokens array requires a `notes` property.');
        }
        if (!this.links) {
          throw new Error('Tokens array requires a `links` property.');
        }
        if (this.options.gfm) {
          if (this.options.breaks) {
            this.rules = inline.breaks;
          } else {
            this.rules = inline.gfm;
          }
        }
      }

      output(src) {
        var cap, href, link, mark, method, num, o, out, ref, text, title;
        out = '';
        while (src) {
          // escape
          if (cap = this.rules.escape.exec(src)) {
            // console.log 'escape', cap
            src = src.slice(cap[0].length);
            out += cap[1];
            continue;
          }
          // autolink
          if (cap = this.rules.autolink.exec(src)) {
            // console.log 'autolink', cap
            src = src.slice(cap[0].length);
            if (cap[2] === '@') {
              text = escape(this.mangle(cap[1]));
              href = 'mailto:' + text;
            } else {
              text = escape(cap[1]);
              href = text;
            }
            out += this.outputLargeBrackets({ text }, { href });
            continue;
          }
          if (!this.inLink && (cap = this.rules.url.exec(src))) {
            // console.log 'url (gfm)', cap
            cap[0] = this.rules._backpedal.exec(cap[0])[0];
            src = src.slice(cap[0].length);
            if (cap[2] === '@') {
              text = escape(cap[0]);
              href = 'mailto:' + text;
            } else {
              text = escape(cap[0]);
              if (cap[1] === 'www.') {
                href = 'http://' + text;
              } else {
                href = text;
              }
            }
            out += this.outputLargeBrackets({ text }, { href });
            continue;
          }
          // tag
          if (cap = this.rules.tag.exec(src)) {
            if (!this.inLink && /^<a /i.test(cap[0])) {
              this.inLink = true;
            } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
              this.inLink = false;
            }
            src = src.slice(cap[0].length);
            out += this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
            continue;
          }
          // link
          if (cap = this.rules.link.exec(src)) {
            // console.log 'link', cap
            src = src.slice(cap[0].length);
            mark = cap[0].charAt(0);
            if (mark === '!') {
              text = escape(cap[1]);
            } else {
              this.inLink = true;
              text = this.output(cap[1]);
              this.inLink = false;
            }
            href = InlineLexer.escapes(cap[2].trim().replace(/^<([\s\S]*)>$/, '$1'));
            title = InlineLexer.escapes(((ref = cap[3]) != null ? ref.slice(1, -1) : void 0) || '');
            out += this.outputLargeBrackets({ mark, text }, { href, title });
            continue;
          }
          // reflink, nolink
          if ((cap = this.rules.reflink.exec(src)) || (cap = this.rules.nolink.exec(src))) {
            // console.log 'ref|no link', cap
            src = src.slice(cap[0].length);
            mark = cap[0].charAt(0);
            link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
            link = this.links[link.toLowerCase()];
            if (!(link != null ? link.href : void 0)) {
              out += mark;
              src = cap[0].slice(1) + src;
              continue;
            }
            if (mark === '!') {
              text = escape(cap[1]);
            } else {
              this.inLink = true;
              text = this.output(cap[1]);
              this.inLink = false;
            }
            out += this.outputLargeBrackets({ mark, text }, link);
            continue;
          }
          // note
          if (cap = this.rules.note.exec(src)) {
            // console.log 'note', cap
            src = src.slice(cap[0].length);
            this.inLink = true;
            text = this.output(cap[1]);
            this.inLink = false;
            this.notes.push(o = { text });
            o.href = '#' + (num = this.notes.length);
            out += this.renderer.note(num, text);
            continue;
          }
          // br
          if (cap = this.rules.br.exec(src)) {
            // console.log 'br', cap
            src = src.slice(cap[0].length);
            out += this.renderer.br();
            continue;
          }
          // strong
          if (cap = this.rules.strong.exec(src)) {
            // console.log 'strong', cap
            src = src.slice(cap[0].length);
            method = function () {
              switch (cap[1]) {
                case '_':
                case '*':
                  return 'strong';
                case '~':
                  // del (gfm)
                  return 'del';
                case '=':
                  // Mark (markdown preview enhanced extended syntax)
                  return 'mark';
              }
            }();
            out += this.renderer[method](this.output(cap[2]));
            continue;
          }
          // em
          if (cap = this.rules.em.exec(src)) {
            // console.log 'em', cap
            src = src.slice(cap[0].length);
            out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));
            continue;
          }
          // sup
          if (cap = this.rules.sup.exec(src)) {
            // console.log 'sup', cap
            src = src.slice(cap[0].length);
            out += this.renderer.sup(this.output(cap[1]));
            continue;
          }
          // sub
          if (cap = this.rules.sub.exec(src)) {
            // console.log 'sub', cap
            src = src.slice(cap[0].length);
            out += this.renderer.sub(this.output(cap[1]));
            continue;
          }
          // code
          if (cap = this.rules.code.exec(src)) {
            // console.log 'code', cap
            src = src.slice(cap[0].length);
            out += this.renderer.codespan(escape(cap[2], true));
            continue;
          }
          // text
          if (cap = this.rules.text.exec(src)) {
            // console.log 'text', cap
            src = src.slice(cap[0].length);
            out += this.renderer.text(escape(this.smartypants(cap[0])));
            continue;
          }
          if (src) {
            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
          }
        }
        return out;
      }

      outputLargeBrackets({ mark, text }, link) {
        var e, href, prot, title;
        ({ href = '', title = '' } = link);
        href && (href = escape(href));
        title && (title = escape(title));
        if (this.options.sanitize) {
          try {
            prot = decodeURIComponent(unescape(href)).replace(/[^\w:]/g, '').toLowerCase();
          } catch (error) {
            e = error;
            return text;
          }
          if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
            return text;
          }
        }
        if (this.options.baseUrl && !originIndependentUrl.test(href)) {
          href = resolveUrl(this.options.baseUrl, href);
        }
        switch (mark) {
          case '!':
            return this.renderer.image(href, title, text);
          default:
            if (this.options.ruby && !this.rules._url_peice.exec(href)) {
              return this.renderer.ruby(href, title, text);
            } else {
              href = encodeURI(href).replace(/%25/g, '%');
              return this.renderer.link(href, title, text);
            }
        }
      }

      smartypants(text) {
        if (!this.options.smartypants) {
          return text;
        }
        return text.replace(/---/g, '—').replace(/--/g, '–').replace(/(^|[-\u2014\/(\[{"\s])'/g, '$1‘').replace(/'/g, '’').replace(/(^|[-\u2014\/(\[{\u2018\s])"/g, '$1“').replace(/"/g, '”').replace(/\.{3}/g, '…');
      }

      mangle(text) {
        var c, ch, i, k, len, out;
        if (!this.options.mangle) {
          return text;
        }
        out = '';
        for (i = k = 0, len = text.length; k < len; i = ++k) {
          c = text[i];
          ch = text.charCodeAt(i);
          if (Math.random() > 0.5) {
            ch = 'x' + ch.toString(16);
          }
          out += '&#' + ch + ';';
        }
        return out;
      }

    };

    /*
     * Expose Inline Rules
     */
    InlineLexer.rules = inline;

    return InlineLexer;
  }.call(this);

  // Renderer
  Renderer = class Renderer {
    constructor(options1) {
      this.options = options1;
    }

    code(code, lang, escaped) {
      var out;
      if (this.options.highlight) {
        out = this.options.highlight(code, lang);
        if (out != null && out !== code) {
          escaped = true;
          code = out;
        }
      }
      code = escaped ? code : escape(code, true);
      if (lang) {
        lang = this.options.langPrefix + escape(lang, true);
        return `<pre><code class="${lang}">${code}</code></pre>`;
      } else {
        return `<pre><code>${code}</code></pre>`;
      }
    }

    blockquote(quote) {
      return `<blockquote>${quote}</blockquote>`;
    }

    html(html) {
      return html;
    }

    heading(text, level, raw) {
      var id;
      if (this.options.headerIds) {
        id = this.options.headerPrefix + raw.toLowerCase().replace(/[^\w]+/g, '-');
        return `<h${level} id="${id}">${text}</h${level}>`;
      } else {
        return `<h${level}>${text}</h${level}>`;
      }
    }

    hr() {
      return '<hr>';
    }

    list(body, ordered, start, taskList) {
      var classNames, start_at, type;
      type = ordered ? "ol" : "ul";
      classNames = taskList ? ' class="task-list"' : '';
      start_at = ordered && start !== 1 ? ` start="${start}" ` : '';
      return `<${type}${start_at}${classNames}>${body}</${type}>`;
    }

    listitem(text, checked) {
      var attr;
      if (checked != null) {
        attr = checked ? " checked" : "";
        return `<li class="task-list-item"><input type="checkbox" class="task-list-item-checkbox"${attr}>${text}</li>`;
      } else {
        return `<li>${text}</li>`;
      }
    }

    paragraph(text, is_top) {
      if (is_top) {
        return `<p>${text}</p>`;
      } else {
        return `${text}`;
      }
    }

    table(header, body) {
      return `<table><thead>${header}</thead><tbody>${body}</tbody></table>`;
    }

    tablerow(content) {
      return `<tr>${content}</tr>`;
    }

    tablecell(content, flags) {
      var style;
      style = flags.align ? `style="text-align:${flags.align}" ` : '';
      if (flags.header) {
        return `<th ${style}>${content}</th>`;
      } else {
        return `<td ${style}>${content}</td>`;
      }
    }

    // span level renderer
    strong(text) {
      return `<strong>${text}</strong>`;
    }

    mark(text) {
      return `<abbr>${text}</abbr>`;
    }

    em(text) {
      return `<em>${text}</em>`;
    }

    sup(text) {
      return `<sup>${text}</sup>`;
    }

    sub(text) {
      return `<sub>${text}</sub>`;
    }

    codespan(text) {
      return `<code>${text}</code>`;
    }

    br() {
      return '\n';
    }

    del(text) {
      return `<del>${text}</del>`;
    }

    ruby(ruby, title, text) {
      if (title) {
        return `<span title="${title}"><ruby>${text}<rp>《</rp><rt>${ruby}</rt><rp>》</rp></ruby></span>`;
      } else {
        return `<ruby>${text}<rp>《</rp><rt>${ruby}</rt><rp>》</rp></ruby>`;
      }
    }

    note(num, title) {
      return `<sup class="note" title="${title}">${num}</sup>`;
    }

    link(href, title, text) {
      if (title) {
        return `<a href="${href}" title="${title}">${text}</a>`;
      } else {
        return `<a href="${href}">${text}</a>`;
      }
    }

    image(href, title, text) {
      if (title) {
        return `<img src="${href}" alt="${text}" title="${title}">`;
      } else {
        return `<img src="${href}" alt="${text}">`;
      }
    }

    anker(code) {
      return `<q cite="${code}">--${code}</q>`;
    }

    text(text) {
      return text;
    }

  };

  TextRenderer = function () {
    var f_link, f_nop, f_text;

    // returns only the textual part of the token
    // no need for block level renderers
    class TextRenderer {};

    f_nop = function () {
      return '';
    };

    f_text = function (text) {
      return text;
    };

    f_link = function (href, title, text) {
      return `${text}`;
    };

    TextRenderer.prototype.strong = f_text;

    TextRenderer.prototype.em = f_text;

    TextRenderer.prototype.codespan = f_text;

    TextRenderer.prototype.del = f_text;

    TextRenderer.prototype.text = f_text;

    TextRenderer.prototype.note = f_text;

    TextRenderer.prototype.link = f_link;

    TextRenderer.prototype.ruby = f_link;

    TextRenderer.prototype.image = f_link;

    TextRenderer.prototype.br = f_nop;

    return TextRenderer;
  }.call(this);

  // Parsing & Compiling
  Parser = class Parser {
    static parse(src, options, renderer) {
      return new Parser(options, renderer).parse(src);
    }

    constructor(options1) {
      this.options = options1;
      this.tokens = [];
      this.token = null;
      ({ renderer: this.renderer } = this.options);
    }

    parse(src) {
      var k, len, notes, out, ref, tag, text;
      this.inline = new InlineLexer(src, this.options);
      // use an InlineLexer with a TextRenderer to extract pure text
      this.inlineText = new InlineLexer(src, Object.assign({}, this.options, {
        renderer: new TextRenderer()
      }));
      this.tokens = src.reverse();
      out = '';
      while (this.next()) {
        out += this.tok();
      }
      if (src.notes.length) {
        out += this.renderer.hr();
        notes = "";
        ref = src.notes;
        for (k = 0, len = ref.length; k < len; k++) {
          ({ text } = ref[k]);
          notes += this.renderer.listitem(text);
        }
        out += this.renderer.list(notes, true, 1);
      }
      tag = this.options.tag;
      if (tag) {
        out = `<${tag}>${out}</${tag}>`;
      }
      return out;
    }

    next() {
      return this.token = this.tokens.pop();
    }

    peek() {
      return this.tokens[this.tokens.length - 1] || 0;
    }

    parseText() {
      var body;
      body = this.token.text;
      while (this.peek().type === 'text') {
        body += '\n' + this.next().text;
      }
      return this.inline.output(body);
    }

    /**
     * Parse Current Token
     */
    tok() {
      var _row, body, cell, checked, flags, header, html, i, j, k, len, len1, len2, m, o, ordered, p, ref, ref1, row, start, taskList, tasklist;
      switch (this.token.type) {
        case 'space':
          return this.token.text;
        case 'hr':
          return this.renderer.hr();
        case 'heading':
          return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, unescape(this.inlineText.output(this.token.text)));
        case 'code':
          return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);
        case 'table':
          cell = '';
          ref = this.token.header;
          for (i = k = 0, len = ref.length; k < len; i = ++k) {
            o = ref[i];
            flags = {
              header: true,
              align: this.token.align[i]
            };
            cell += this.renderer.tablecell(this.inline.output(o), {
              header: true,
              align: this.token.align[i]
            });
          }
          header = this.renderer.tablerow(cell);
          body = '';
          ref1 = this.token.cells;
          for (i = m = 0, len1 = ref1.length; m < len1; i = ++m) {
            row = ref1[i];
            cell = '';
            for (j = p = 0, len2 = row.length; p < len2; j = ++p) {
              _row = row[j];
              cell += this.renderer.tablecell(this.inline.output(_row), {
                header: false,
                align: this.token.align[j]
              });
            }
            body += this.renderer.tablerow(cell);
          }
          return this.renderer.table(header, body);
        case 'blockquote_start':
          body = '';
          while (this.next().type !== 'blockquote_end') {
            body += this.tok();
          }
          return this.renderer.blockquote(body);
        case 'list_start':
          ({ ordered, start } = this.token);
          body = '';
          tasklist = false;
          while (this.next().type !== 'list_end') {
            if (this.token.checked != null) {
              taskList = true;
            }
            body += this.tok();
          }
          return this.renderer.list(body, ordered, start, taskList);
        case 'list_item_start':
          body = '';
          ({ checked } = this.token);
          while (this.next().type !== 'list_item_end') {
            body += this.token.type === 'text' ? this.parseText() : this.tok();
          }
          return this.renderer.listitem(body, checked);
        case 'loose_item_start':
          body = '';
          ({ checked } = this.token);
          while (this.next().type !== 'list_item_end') {
            body += this.tok();
          }
          return this.renderer.listitem(body, checked);
        case 'html':
          html = !this.token.pre ? this.inline.output(this.token.text) : this.token.text;
          return this.renderer.html(html);
        case 'paragraph':
          return this.renderer.paragraph(this.inline.output(this.token.text), true);
        case 'text':
          return this.renderer.paragraph(this.parseText(), this.token.top);
      }
    }

  };

  // Marked
  marked = function (src, opt) {
    var e, message, tokens, txt;
    // throw error in case of non string input
    if (!src) {
      throw new Error('marked(): input parameter is undefined or null');
    }
    if (typeof src !== 'string') {
      txt = Object.prototype.toString.call(src);
      throw new Error(`marked(): input parameter is of type ${txt}, string expected`);
    }
    try {
      opt = Object.assign({}, marked.defaults, opt);
      opt.renderer.options = opt;
      tokens = Lexer.lex(src, opt);
      return Parser.parse(tokens, opt);
    } catch (error) {
      e = error;
      e.message += '\nPlease report this to https://github.com/7korobi/marked.';
      if ((opt || marked.defaults).silent) {
        message = escape(e.message + '', true);
        return `<p>An error occured:</p><pre>${message}</pre>`;
      }
      throw e;
    }
  };

  // Options
  marked.options = marked.setOptions = function (opt) {
    Object.assign(marked.defaults, opt);
    return marked;
  };

  marked.getDefaults = function () {
    return {
      baseUrl: null,
      breaks: false,
      gfm: true,
      headerIds: true,
      headerPrefix: '',
      highlight: null,
      langPrefix: 'language-',
      mangle: true,
      pedantic: false,
      renderer: new Renderer(),
      sanitize: false,
      sanitizer: null,
      silent: false,
      smartLists: false,
      smartypants: false,
      tables: true,
      xhtml: false,
      ruby: false,
      indentCode: true,
      taskLists: true,
      tag: null
    };
  };

  marked.defaults = marked.getDefaults();

  // Expose
  marked.Parser = Parser;

  marked.parser = Parser.parse;

  marked.Renderer = Renderer;

  marked.TextRenderer = TextRenderer;

  marked.Lexer = Lexer;

  marked.lexer = Lexer.lex;

  marked.InlineLexer = InlineLexer;

  marked.inlineLexer = InlineLexer.output;

  marked.parse = marked;

  module.exports = marked;
}).call(this);
//# sourceMappingURL=marked.js.map
