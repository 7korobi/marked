// Generated by CoffeeScript 2.1.0
(function () {
  // Helpers
  var InlineLexer, Lexer, Parser, Renderer, block, escape, inline, marked, noop, replace, unescape;

  escape = function (html, encode) {
    var amp;
    amp = encode ? /&/g : /&(?!#?\w+;)/g;
    return html.replace(amp, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
  };

  unescape = function (html) {
    // explicitly match decimal, hex, and named HTML entities 
    return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/g, function (_, n) {
      n = n.toLowerCase();
      if (n === 'colon') {
        return ':';
      }
      if (n.charAt(0) === '#') {
        if (n.charAt(1) === 'x') {
          return String.fromCharCode(parseInt(n.substring(2), 16));
        } else {
          return String.fromCharCode(+n.substring(1));
        }
      }
      return '';
    });
  };

  replace = function (regex, opt) {
    var self;
    regex = regex.source;
    opt = opt || '';
    self = function (name, val) {
      if (!name) {
        return new RegExp(regex, opt);
      }
      val = val.source || val;
      val = val.replace(/(^|[^\[])\^/g, '$1');
      regex = regex.replace(name, val);
      return self;
    };
    return self;
  };

  noop = function () {};

  noop.exec = noop;

  // Block Lexer
  block = {
    newline: /^\n+/,
    code: /^( {4}[^\n]+\n*)+/,
    fences: noop,
    hr: /^( *[-*_]){3,} *(?:\n|$)/,
    heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n|$)/,
    nptable: noop,
    lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n|$)/,
    blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
    list: /^( *)(bull)[\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull)\n*|\s*$)/,
    html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
    def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n|$)/,
    table: noop,
    paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
    text: /^[^\n]+/
  };

  block.bullet = /(?:[*+-] |\d+\.)/;

  block.item = /^( *)(bull)[^\n]*(?:\n(?!\1bull)[^\n]*)*/;

  block.item = replace(block.item, 'gm')(/bull/g, block.bullet)();

  block.list = replace(block.list)(/bull/g, block.bullet)('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')('def', '\\n+(?=' + block.def.source + ')')();

  block.blockquote = replace(block.blockquote)('def', block.def)();

  block._tag = '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code' + '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo' + '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';

  block.html = replace(block.html)('comment', /<!--[\s\S]*?-->/)('closed', /<(tag)[\s\S]+?<\/\1>/)('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)(/tag/g, block._tag)();

  block.paragraph = replace(block.paragraph)('hr', block.hr)('heading', block.heading)('lheading', block.lheading)('blockquote', block.blockquote)('tag', '<' + block._tag)('def', block.def)();

  // Normal Block Grammar
  block.normal = Object.assign({}, block);

  // GFM Block Grammar
  block.gfm = Object.assign({}, block.normal, {
    fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(\n|$)/,
    paragraph: /^/,
    heading: /^ *(#{1,6}) +([^\n]+?) *#* *(\n|$)/,
    checkbox: /^\[([ x])\] +/
  });

  block.gfm.paragraph = replace(block.paragraph)('(?!', '(?!', +block.gfm.fences.source.replace('\\1', '\\2') + '|', +block.list.source.replace('\\1', '\\3') + '|')();

  // GFM + Tables Block Grammar
  block.tables = Object.assign({}, block.gfm, {
    nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
    table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
  });

  Lexer = function () {
    class Lexer {
      static lex(src, options) {
        return new Lexer(options).lex(src);
      }

      constructor(options) {
        this.tokens = [];
        this.tokens.links = {};
        this.options = options || marked.defaults;
        this.rules = block.normal;
        if (this.options.gfm) {
          this.rules = this.options.tables ? block.tables : block.gfm;
        }
      }

      lex(src) {
        src = src.replace(/\r\n|\r/g, '\n').replace(/\t/g, '    ').replace(/\u00a0/g, ' ').replace(/\u2424/g, '\n');
        return this.token(src, true);
      }

      token(src, top, bq) {
        var b, bull, cap, i, item, k, l, len, len1, len2, len3, loose, m, next, o, p, q, ref, ref1, ref2, ref3, ref4, space;
        src = src.replace(/^ +$/gm, '');
        while (src) {
          // newline
          if (cap = this.rules.newline.exec(src)) {
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: 'space',
              text: cap[0]
            });
          }
          // code
          if (cap = this.rules.code.exec(src)) {
            src = src.slice(cap[0].length);
            cap = cap[0].replace(/^ {4}/gm, '');
            this.tokens.push({
              type: 'code',
              text: cap
            });
            continue;
          }
          // fences (gfm)
          if (cap = this.rules.fences.exec(src)) {
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: 'code',
              lang: cap[2],
              text: cap[3] || ''
            });
            continue;
          }
          // heading
          if (cap = this.rules.heading.exec(src)) {
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: 'heading',
              depth: cap[1].length,
              text: cap[2]
            });
            continue;
          }
          // table no leading pipe (gfm)
          if (top && (cap = this.rules.nptable.exec(src))) {
            src = src.slice(cap[0].length);
            item = {
              type: 'table',
              header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
              align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
              cells: cap[3].replace(/\n$/, '').split('\n')
            };
            ref = item.align;
            for (i = k = 0, len = ref.length; k < len; i = ++k) {
              o = ref[i];
              item.align[i] = /^ *-+: *$/.test(o) ? 'right' : /^ *:-+: *$/.test(o) ? 'center' : /^ *:-+ *$/.test(o) ? 'left' : null;
            }
            ref1 = item.cells;
            for (i = m = 0, len1 = ref1.length; m < len1; i = ++m) {
              o = ref1[i];
              item.cells[i] = o.split(/ *\| */);
            }
            this.tokens.push(item);
            continue;
          }
          // lheading
          if (cap = this.rules.lheading.exec(src)) {
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: 'heading',
              depth: cap[2] === '=' ? 1 : 2,
              text: cap[1]
            });
            continue;
          }

          // hr
          if (cap = this.rules.hr.exec(src)) {
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: 'hr'
            });
            continue;
          }
          // blockquote
          if (cap = this.rules.blockquote.exec(src)) {
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: 'blockquote_start'
            });
            cap = cap[0].replace(/^ *> ?/gm, '');
            // Pass `top` to keep the current
            // "toplevel" state. This is exactly
            // how markdown.pl works.
            this.token(cap, top, true);
            this.tokens.push({
              type: 'blockquote_end'
            });
            continue;
          }
          // list
          if (cap = this.rules.list.exec(src)) {
            src = src.slice(cap[0].length);
            bull = cap[2];
            this.tokens.push({
              type: 'list_start',
              ordered: "." === bull.slice(-1)
            });
            // Get each top-level item.
            cap = cap[0].match(this.rules.item);
            next = false;
            l = cap.length;
            i = 0;
            while (i < l) {
              item = cap[i];
              // Remove the list item's bullet
              // so it is seen as the next token.
              space = item.length;
              item = item.replace(/^ *([*+-]+ |(\d+\.)+)/, '');
              if (~item.indexOf('\n ')) {
                space -= item.length;
                item = item.replace(RegExp(`^ {1,${space}}`, "gm"), '');
              }
              // Determine whether the next list item belongs here.
              // Backpedal if it does not belong in this list.
              if (this.options.smartLists && i !== l - 1) {
                b = block.bullet.exec(cap[i + 1])[0];
                if (bull !== b && !(bull.length > 1 && b.length > 1)) {
                  src = cap.slice(i + 1).join('\n') + src;
                  i = l - 1;
                }
              }
              // Determine whether item is loose or not.
              // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
              // for discount behavior.
              loose = next || /\n\n(?!\s*$)/.test(item);
              if (i !== l - 1) {
                next = item.charAt(item.length - 1) === '\n';
                if (!loose) {
                  loose = next;
                }
              }
              this.tokens.push({
                type: loose ? 'loose_item_start' : 'list_item_start'
              });
              // Recurse.
              this.token(item, false, bq);
              this.tokens.push({
                type: 'list_item_end'
              });
              i++;
            }
            this.tokens.push({
              type: 'list_end'
            });
            continue;
          }
          // html
          if (cap = this.rules.html.exec(src)) {
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: this.options.sanitize ? 'paragraph' : 'html',
              pre: !this.options.sanitizer && ((ref2 = cap[1]) === 'pre' || ref2 === 'script' || ref2 === 'style'),
              text: cap[0]
            });
            continue;
          }
          if (!bq && top && (cap = this.rules.def.exec(src))) {
            src = src.slice(cap[0].length);
            this.tokens.links[cap[1].toLowerCase()] = {
              href: cap[2],
              title: cap[3]
            };
            continue;
          }
          // table (gfm)
          if (top && (cap = this.rules.table.exec(src))) {
            src = src.slice(cap[0].length);
            item = {
              type: 'table',
              header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
              align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
              cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
            };
            ref3 = item.align;
            for (i = p = 0, len2 = ref3.length; p < len2; i = ++p) {
              o = ref3[i];
              item.align[i] = /^ *-+: *$/.test(o) ? 'right' : /^ *:-+: *$/.test(o) ? 'center' : /^ *:-+ *$/.test(o) ? 'left' : null;
            }
            ref4 = item.cells;
            for (i = q = 0, len3 = ref4.length; q < len3; i = ++q) {
              o = ref4[i];
              item.cells[i] = o.replace(/^ *\| *| *\| *$/g, '').split(/ *\| */);
            }
            this.tokens.push(item);
            continue;
          }
          // top-level paragraph
          if (top && (cap = this.rules.paragraph.exec(src))) {
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: 'paragraph',
              text: cap[0]
            });
            continue;
          }
          // text
          if (cap = this.rules.text.exec(src)) {
            // Top-level should never reach here.
            src = src.slice(cap[0].length);
            this.tokens.push({
              type: 'text',
              text: cap[0]
            });
            continue;
          }
          if (src) {
            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
          }
        }
        return this.tokens;
      }

    };

    Lexer.rules = block;

    return Lexer;
  }();

  // Inline Lexer & Compiler
  inline = {
    escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
    autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
    url: noop,
    tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
    link: /^!?\[(inside)\]\(href\)/,
    reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
    nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
    strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
    em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
    code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
    br: /^ {2,}\n(?!\s*$)/,
    del: noop,
    text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
  };

  inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;

  inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;

  inline.link = replace(inline.link)('inside', inline._inside)('href', inline._href)();

  inline.reflink = replace(inline.reflink)('inside', inline._inside)();

  // Normal Inline Grammar
  inline.normal = Object.assign({}, inline);

  // GFM Inline Grammar
  inline.gfm = Object.assign({}, inline.normal, {
    escape: replace(inline.escape)('])', '~|])')(),
    url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
    del: /^~~(?=\S)([\s\S]*?\S)~~/,
    text: replace(inline.text)(']|', '~]|')('|', '|https?://|')()
  });

  // GFM + Line Breaks Inline Grammar
  inline.breaks = Object.assign({}, inline.gfm, {
    br: replace(inline.br)('{2,}', '*')(),
    text: replace(inline.gfm.text)('{2,}', '*')(']|', '/]|')()
  });

  InlineLexer = function () {
    // Expose Inline Rules
    class InlineLexer {
      static output(src, links, options) {
        return new InlineLexer(links, options).output(src);
      }

      constructor(links, options) {
        this.options = options || marked.defaults;
        this.links = links;
        this.rules = inline.normal;
        this.renderer = this.options.renderer || new Renderer();
        this.renderer.options = this.options;
        if (!this.links) {
          throw new Error('Tokens array requires a `links` property.');
        }
        if (this.options.gfm) {
          if (this.options.breaks) {
            this.rules = inline.breaks;
          } else {
            this.rules = inline.gfm;
          }
        }
      }

      output(src) {
        var cap, href, link, out, text;
        out = '';
        while (src) {
          // escape
          if (cap = this.rules.escape.exec(src)) {
            src = src.slice(cap[0].length);
            out += cap[1];
            continue;
          }
          // autolink
          if (cap = this.rules.autolink.exec(src)) {
            src = src.slice(cap[0].length);
            if (cap[2] === '@') {
              text = cap[1].charAt(6) === ':' ? this.mangle(cap[1].slice(7)) : this.mangle(cap[1]);
              href = this.mangle('mailto:') + text;
            } else {
              text = escape(cap[1]);
              href = text;
            }
            out += this.renderer.link(href, null, text);
            continue;
          }
          if (!this.inLink && (cap = this.rules.url.exec(src))) {
            src = src.slice(cap[0].length);
            text = escape(cap[1]);
            href = text;
            out += this.renderer.link(href, null, text);
            continue;
          }
          // tag
          if (cap = this.rules.tag.exec(src)) {
            if (!this.inLink && /^<a /i.test(cap[0])) {
              this.inLink = true;
            } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
              this.inLink = false;
            }
            src = src.slice(cap[0].length);
            out += this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0]) : cap[0];
            continue;
          }
          // link
          if (cap = this.rules.link.exec(src)) {
            src = src.slice(cap[0].length);
            this.inLink = true;
            out += this.outputLink(cap, {
              href: cap[2],
              title: cap[3]
            });
            this.inLink = false;
            continue;
          }
          // reflink, nolink
          if ((cap = this.rules.reflink.exec(src)) || (cap = this.rules.nolink.exec(src))) {
            link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
            link = this.links[link.toLowerCase()];
            if (!link || !link.href) {
              src = src.slice(1);
              out += cap[0].charAt(0);
            } else {
              src = src.slice(cap[0].length);
              this.inLink = true;
              out += this.outputLink(cap, link);
              this.inLink = false;
            }
            continue;
          }
          // strong
          if (cap = this.rules.strong.exec(src)) {
            src = src.slice(cap[0].length);
            out += this.renderer.strong(this.output(cap[2] || cap[1]));
            continue;
          }
          // em
          if (cap = this.rules.em.exec(src)) {
            src = src.slice(cap[0].length);
            out += this.renderer.em(this.output(cap[2] || cap[1]));
            continue;
          }
          // code
          if (cap = this.rules.code.exec(src)) {
            src = src.slice(cap[0].length);
            out += this.renderer.codespan(escape(cap[2], true));
            continue;
          }
          // br
          if (cap = this.rules.br.exec(src)) {
            src = src.slice(cap[0].length);
            out += this.renderer.br();
            continue;
          }
          // del (gfm)
          if (cap = this.rules.del.exec(src)) {
            src = src.slice(cap[0].length);
            out += this.renderer.del(this.output(cap[1]));
            continue;
          }
          // text
          if (cap = this.rules.text.exec(src)) {
            src = src.slice(cap[0].length);
            out += this.renderer.text(escape(this.smartypants(cap[0])));
            continue;
          }
          if (src) {
            throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
          }
        }
        return out;
      }

      outputLink(cap, link) {
        var href, title;
        href = escape(link.href);
        title = link.title ? escape(link.title) : null;
        if (cap[0].charAt(0) !== '!') {
          return this.renderer.link(href, title, this.output(cap[1]));
        } else {
          return this.renderer.image(href, title, escape(cap[1]));
        }
      }

      smartypants(text) {
        if (!this.options.smartypants) {
          return text;
        }
        return text.replace(/---/g, '—').replace(/--/g, '–').replace(/(^|[-\u2014\/(\[{"\s])'/g, '$1‘').replace(/'/g, '’').replace(/(^|[-\u2014\/(\[{\u2018\s])"/g, '$1“').replace(/"/g, '”').replace(/\.{3}/g, '…');
      }

      mangle(text) {
        var c, ch, i, k, len, out;
        if (!this.options.mangle) {
          return text;
        }
        out = '';
        for (i = k = 0, len = text.length; k < len; i = ++k) {
          c = text[i];
          ch = text.charCodeAt(i);
          if (Math.random() > 0.5) {
            ch = 'x' + ch.toString(16);
          }
          out += '&#' + ch + ';';
        }
        return out;
      }

    };

    InlineLexer.rules = inline;

    return InlineLexer;
  }();

  // Renderer
  Renderer = class Renderer {
    constructor(options) {
      this.options = options || {};
    }

    code(code, lang, escaped) {
      var out;
      if (this.options.highlight) {
        out = this.options.highlight(code, lang);
        if (out != null && out !== code) {
          escaped = true;
          code = out;
        }
      }
      code = escaped ? code : escape(code, true);
      if (lang) {
        lang = this.options.langPrefix + escape(lang, true);
        return `<pre><code class="${lang}">${code}</code></pre>`;
      } else {
        return `<pre><code>${code}</code></pre>`;
      }
    }

    blockquote(quote) {
      return `<blockquote>${quote}</blockquote>`;
    }

    html(html) {
      return html;
    }

    heading(text, level, raw) {
      var id;
      id = this.options.headerPrefix + raw.toLowerCase().replace(/[^\w]+/g, '-');
      return `<h${level} id="${id}">${text}</h${level}>`;
    }

    hr() {
      return '<hr>';
    }

    list(body, ordered) {
      if (ordered) {
        return `<ol>${body}</ol>`;
      } else {
        return `<ul>${body}</ul>`;
      }
    }

    listitem(text) {
      return `<li>${text}</li>`;
    }

    paragraph(text) {
      return `<p>${text}</p>`;
    }

    table(header, body) {
      return `<table><thead>${header}</thead><tbody>${body}</tbody></table>`;
    }

    tablerow(content) {
      return `<tr>${content}</tr>`;
    }

    tablecell(content, flags) {
      var style;
      style = flags.align ? `style="text-align:${flags.align}" ` : '';
      if (flags.header) {
        return `<th ${style}>${content}</th>`;
      } else {
        return `<td ${style}>${content}</td>`;
      }
    }

    // span level renderer
    strong(text) {
      return `<strong>${text}</strong>`;
    }

    em(text) {
      return `<em>${text}</em>`;
    }

    codespan(text) {
      return `<code>${text}</code>`;
    }

    br() {
      return '\n';
    }

    del(text) {
      return `<del>${text}</del>`;
    }

    link(href, title, text) {
      var e, prot;
      if (this.options.sanitize) {
        try {
          prot = decodeURIComponent(unescape(href)).replace(/[^\w:]/g, '').toLowerCase();
        } catch (error) {
          e = error;
          return '';
        }
        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
          return '';
        }
      }
      if (title) {
        return `<a href="${href}" title="${title}">${text}</a>`;
      } else {
        return `<a href="${href}">${text}</a>`;
      }
    }

    image(href, title, text) {
      if (title) {
        return `<img src="${href}" alt="${text}" title="${title}">`;
      } else {
        return `<img src="${href}" alt="${text}">`;
      }
    }

    text(text) {
      return text;
    }

  };

  // Parsing & Compiling
  Parser = class Parser {
    static parse(src, options, renderer) {
      return new Parser(options, renderer).parse(src);
    }

    constructor(options) {
      this.tokens = [];
      this.token = null;
      this.options = options || marked.defaults;
      this.options.renderer = this.options.renderer || new Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
    }

    parse(src) {
      var out, tag;
      this.inline = new InlineLexer(src.links, this.options, this.renderer);
      this.tokens = src.reverse();
      out = '';
      while (this.next()) {
        out += this.tok();
      }
      tag = this.options.tag;
      if (tag) {
        out = `<${tag}>${out}</${tag}>`;
      }
      return out;
    }

    next() {
      return this.token = this.tokens.pop();
    }

    peek() {
      return this.tokens[this.tokens.length - 1] || 0;
    }

    parseText() {
      var body;
      body = this.token.text;
      while (this.peek().type === 'text') {
        body += '\n' + this.next().text;
      }
      return this.inline.output(body);
    }

    /**
     * Parse Current Token
     */
    tok() {
      var _row, body, cell, flags, header, html, i, j, k, len, len1, len2, m, o, ordered, p, ref, ref1, row;
      switch (this.token.type) {
        case 'space':
          return this.token.text;
        case 'hr':
          return this.renderer.hr();
        case 'heading':
          return this.renderer.heading(this.inline.output(this.token.text), this.token.depth, this.token.text);
        case 'code':
          return this.renderer.code(this.token.text, this.token.lang, this.token.escaped);
        case 'table':
          cell = '';
          ref = this.token.header;
          for (i = k = 0, len = ref.length; k < len; i = ++k) {
            o = ref[i];
            flags = {
              header: true,
              align: this.token.align[i]
            };
            cell += this.renderer.tablecell(this.inline.output(o), {
              header: true,
              align: this.token.align[i]
            });
          }
          header = this.renderer.tablerow(cell);
          body = '';
          ref1 = this.token.cells;
          for (i = m = 0, len1 = ref1.length; m < len1; i = ++m) {
            row = ref1[i];
            cell = '';
            for (j = p = 0, len2 = row.length; p < len2; j = ++p) {
              _row = row[j];
              cell += this.renderer.tablecell(this.inline.output(_row), {
                header: false,
                align: this.token.align[j]
              });
            }
            body += this.renderer.tablerow(cell);
          }
          return this.renderer.table(header, body);
        case 'blockquote_start':
          body = '';
          while (this.next().type !== 'blockquote_end') {
            body += this.tok();
          }
          return this.renderer.blockquote(body);
        case 'list_start':
          body = '';
          ordered = this.token.ordered;
          while (this.next().type !== 'list_end') {
            body += this.tok();
          }
          return this.renderer.list(body, ordered);
        case 'list_item_start':
          body = '';
          while (this.next().type !== 'list_item_end') {
            body += this.token.type === 'text' ? this.parseText() : this.tok();
          }
          return this.renderer.listitem(body);
        case 'loose_item_start':
          body = '';
          while (this.next().type !== 'list_item_end') {
            body += this.tok();
          }
          return this.renderer.listitem(body);
        case 'html':
          html = !this.token.pre ? this.inline.output(this.token.text) : this.token.text;
          return this.renderer.html(html);
        case 'paragraph':
          return this.renderer.paragraph(this.inline.output(this.token.text));
        case 'text':
          return this.renderer.paragraph(this.parseText());
      }
    }

  };

  // Marked
  marked = function (src, opt, callback) {
    var done, e, highlight, pending, tokens;
    if (callback || typeof opt === 'function') {
      if (!callback) {
        callback = opt;
        opt = null;
      }
      opt = Object.assign({}, marked.defaults, opt || {});
      highlight = opt.highlight;
      try {
        tokens = Lexer.lex(src, opt);
      } catch (error) {
        e = error;
        return callback(e);
      }
      pending = tokens.length;
      done = function (err) {
        var out;
        if (err) {
          opt.highlight = highlight;
          return callback(err);
        }
        try {
          out = Parser.parse(tokens, opt);
        } catch (error) {
          e = error;
          err = e;
        }
        opt.highlight = highlight;
        if (err) {
          return callback(err);
        } else {
          return callback(null, out);
        }
      };
      if (!highlight || highlight.length < 3) {
        return done();
      }
      delete opt.highlight;
      if (!pending) {
        return done();
      }
      tokens.map(function (token) {
        if (token.type !== 'code') {
          return --pending || done();
        }
        highlight(token.text, token.lang, function (err, code) {
          if (err) {
            return done(err);
          }
          if (code === null || code === token.text) {
            return --pending || done();
          }
          token.text = code;
          token.escaped = true;
          --pending || done();
        });
      });
      return;
    }
    try {
      if (opt) {
        opt = Object.assign({}, marked.defaults, opt);
      }
      return Parser.parse(Lexer.lex(src, opt), opt);
    } catch (error) {
      e = error;
      e.message += '\nPlease report this to https://github.com/chjj/marked.';
      if ((opt || marked.defaults).silent) {
        return '<p>An error occured:</p><pre>' + escape(e.message + '', true) + '</pre>';
      }
      throw e;
    }
  };

  // Options
  marked.options = marked.setOptions = function (opt) {
    Object.assign(marked.defaults, opt);
    return marked;
  };

  marked.defaults = {
    tag: null,
    gfm: true,
    tables: true,
    breaks: false,
    sanitize: false,
    sanitizer: null,
    mangle: true,
    smartLists: false,
    silent: false,
    highlight: null,
    langPrefix: 'lang-',
    smartypants: false,
    headerPrefix: '',
    renderer: new Renderer()
  };

  // Expose
  marked.Parser = Parser;

  marked.parser = Parser.parse;

  marked.Renderer = Renderer;

  marked.Lexer = Lexer;

  marked.lexer = Lexer.lex;

  marked.InlineLexer = InlineLexer;

  marked.inlineLexer = InlineLexer.output;

  marked.parse = marked;

  module.exports = marked;
}).call(this);
//# sourceMappingURL=marked.js.map
